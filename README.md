# TypeScriptでデザインパターン

## オブジェクトの生成に関するパターン
### FactoryMethodパターン  
インスタンスの生成をサブクラスに任せます。その結果、インスタンス生成を柔軟に行うことが可能になります。  

### AbstractFactoryパターン
関連したり依存しあうオブジェクト群のインスタンスを生成することができます。  

### Builderパターン
複雑なインスタンスを段階的に作成します。

### Prototypeパターン
原型オブジェクトをいくつか用意しておき、それらをコピーしてインスタンスを生成します

### Singletonパターン
インスタンスが一つだけしか存在しないクラスを作ります。

## プログラムの構造に関するパターン
###  Adapterパターン
あるクラスのインターフェースを、別のインターフェースに変換することができます。
### Bridgeパターン
機能と実装の階層を分けます。それにより、機能と実装を独立して拡張することができます。
### Compositeパターン
オブジェクトを木構造で表現し、再帰的な処理を行います。
### Decoratorパターン
クラスの組み合わせを変えることで機能の追加ができます。
### Facadeパターン
複雑な処理をまとめて、インターフェースとして公開します。
### FlyWeightパターン
一度生成したインスタンスを共有して再利用することで、処理スピードを改善します。
### Proxyパターン
時間のかかる処理を最後まで遅らせます。そうすることで、本当にその処理が必要になった時だけ処理を行います。
もしも処理が不要になった場合は、処理を行わないため性能が改善されることがあります。

## オブジェクトの振る舞いに関するパターン
### Chain of Responsibilityパターン
処理を依頼する側と、受け取る側の結合を緩やかにします。それにより、オブジェクトの再利用性を高めます。
### Commandパターン
どのような処理を行ったのか履歴管理するためにCommandパターンが使われます。
また、取り消し可能なオペレーションを作成することも可能です。
### Interpreterパターン
簡単な言語を解釈して、動的な処理を実行することができます。
### Iteratorパターン
集約オブジェクトに依存せずにオブジェクトにアクセスできるようになります。
### Mediatorパターン
各オブジェクト間のやり取りを一箇所に集めることができます。それにより、オブジェクト間の独立せいを高め、再利用性を高くします。
### Mementoパターン
オブジェクトの状態を元に戻すことができます。それにより、操作の取り消しや実行ができるようになります。
### Stateパターン
状態を表すクラスを導入することで、状態による状態分岐をなくします。それにより拡張性を高めることができます。
### Strategyパターン
アルゴリズムの追加・変更を容易にします。また、アルゴリズム自体を切り替えることもできます。
### TemplateMethodパターン
アルゴリズムの構造は変えずに、似たような処理を複数作ることができます。
### Visitorパターン
データ構造と処理を分離します。それによって、拡張性を高めることができます。